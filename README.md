# Постановка задачи

Необходимо написать относительно простой сервис, который минимизирует ссылки.

Хочется, чтобы был REST и страница с формой через которую можно ссылку сгенерировать.

Через REST должна быть возможность добавить/удалить/изменить полную ссылку.

Пользователь отправляет полную ссылку в сервис, а в ответ получает минимизированную ссылку.

Если по короткой ссылке перейти, соответственно должно произойти перенаправление на полную ссылку.

Так же предполагается, что у сервиса будет большой rps на любые методы и хочется чтобы он мог генерировать бесконечно
 большое кол-во ссылок и чтобы они были действительно минимально возможными на момент создания.

# Использованное решение задачи
Для минимизации количества запросов и исключения получения текущего минимального значения ссылки был использован принцип
перевода идентификатора сохраненной длинной ссылки в короткий URL и обратно. Таким образом
необходимо лишь сохранить длинный URL, получить идентификатор сохраненный записи и несложными вычислениями получить
короткий URL. Соответственно путем обратного преобразования их короткого URL получается идентификатор длинной ссылки,
по которому эта ссылка получается из БД. Фактически при преобразованиях осуществляется перевод из
десятичной системы счисления в 62-чную (по 26 букв в верхнем и нижнем регистре и 10 цифр) и обратно.
С учетом того, что таких идентификаторов может быть создано 2^63-1, то можно сказать, что обеспечивается хранение
практически бесконечного количества ссылок, даже если их создавать по триллиону в день.

# Запуск
1. Выполняем `docker-compose -d up`.
1. После запуска контейнеров выполняем `docker-compose run php bash`.
1. Для установки зависимостей выполняем `composer install`.
1. Выполняем миграции `./yii migrate --interactive=0`.
1. Решение становится доступно по адресу http://localhost:8000

# Запуск тестов
Выполняем шаги из предыдущего раздела.
1. Генерируем вспомогательный код для тестирования `vendor/bin/codecept build`.
1. Запускаем тесты `vendor/bin/codecept run`. 

# Замечания
- в условиях задачи упоминаются высокие нагрузки. Вместо файлового кэша, очевидно, нужно подключить Redis.
 Не сделано, т.к. принципиального влияния на решение не имеет.
- параметры подключения к БД вместо хардкода необходимо заменить на получение таковых из каких-то источников
 конфигурации - обычно переменных окружения. Не сделано, т.к. принципиального влияния на решение не имеет.
- поле в БД создано как varchar(2000). В зависимости от реальной задачи его длина может быть установлена
 заказчиком. Если бы была поставлена задача хранить URL без ограничения по длине, то его можно было бы сделать
 типом text.
- пропущено оформление страницы с формой и валидация csrf, т.к. к задаче особого отношения не имеет.
